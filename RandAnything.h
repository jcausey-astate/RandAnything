#ifndef RANDANYTHING_H
#define RANDANYTHING_H
/**
 * @file RandAnything.h
 * Defines a class RandAnything that will allow you to quickly
 * generate a quality pseudo-random value of (almost) any
 * standard type without worrying about STL type names or
 * doing a lot of setup.
 *
 * @copyright 2015 Jason L Causey, Arkansas State University
 *                                 Department of Computer Science
 *
 *  The MIT License (MIT)  http://opensource.org/licenses/MIT
 *
 *  Copyright (c) 2015 Jason L Causey, Arkansas State University
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the rights
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in
 *  all copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 *  THE SOFTWARE.
 */
#include <random>
#include <type_traits>
#include <memory>

/*
 * Note: The "type tagging" concept used here is adapted from:
 * http://stackoverflow.com/a/30106536
 */
struct integral_type{};
struct real_type{};
struct string_type{};
struct other_type{};

template <typename T>
struct type_tag
:   std::conditional<
        std::is_integral<T>::value,
        integral_type,
        typename std::conditional<
            std::is_floating_point<T>::value,
            real_type,
            typename std::conditional<
                std::is_same<T, std::string>::value,
                string_type,
                other_type
            >::type
        >::type
    >
{   };

template <typename T>
using get_type_tag = typename type_tag<T>::type;

template <typename ValueType>
ValueType generate_rand(const ValueType& low, const ValueType& high, std::mt19937& gen, integral_type);
template <typename ValueType>
ValueType generate_rand(const ValueType& low, const ValueType& high, std::mt19937& gen, real_type);
template <typename ValueType>
ValueType generate_rand(const ValueType&, const ValueType&, std::mt19937&, other_type) = delete;
/*
 * Helper function that asserts that the type bound to the RandAnything instance
 * is actually capable of being generated by this version of RandAnything.
 */
template <typename T> inline void verify_type_compatibility(){
    static_assert( std::is_integral<T>::value
                   || std::is_floating_point<T>::value,
                   "Unsupported type. RandAnything works with integral, floating-point, and std::string types."
                 );
}

/*
 * Super-class to encapsulate the common random-number generator and seeing machinery
 * used by both the "numeric" and "string" RandAnything implementations.
 */
class _RandBase{
public:
    _RandBase();
    _RandBase(unsigned int seed);
protected:
    std::unique_ptr< std::random_device >       seeder;
    std::mt19937                                generator;
};
/*
 * Construct the random number generator using non-deterministic random values (if available).
 */
inline _RandBase::_RandBase()                  : seeder{new std::random_device}, generator{(*seeder)()}   { }
/*
 * Construct the random number generator given an explicit seed value in `seed` parameter.
 *
 * @param seed  explicit seed value for the PRNG
 */
inline _RandBase::_RandBase(unsigned int seed) : seeder{nullptr},                generator{seed}          { }

/**
 * @brief   Generate a random value of any numeric type or std::string.
 * @details Generate (almost) any type of uniform random value in a range [low,high]
 *          (for integral values) or [low, high) (for floating-point values).
 *          Just instantiate the class with whatever type you want as the template
 *          argument, then use it as a function where the arguments are the
 *          lower and upper bounds of the range for the resulting random value.
 *          To generate `std::string` values, @seealso RandAnything<std::string>
 *          specialization.
 *
 * @tparam ValueType Type of value that should be generated.  Supports integral types,
 *                   Real-number types, and `std::string`.
 */
template <typename ValueType>
class RandAnything : public _RandBase{
public:
    RandAnything();
    RandAnything(unsigned int seed);
    ValueType operator() (const ValueType& low, const ValueType& high);
private:
    RandAnything  (const RandAnything&)         = delete;
    void operator=(const RandAnything&)         = delete;
};
/**
 * constructs the random number generator and prepares it for use; seeding is automatic
 * and uses a non-deterministic seed (if available on the system)
 *
 * @tparam ValueType Type of value that should be generated.  Supports integral types,
 *                   Real-number types, and `std::string`.
 */
template <typename ValueType>
RandAnything<ValueType>::RandAnything()                                     { verify_type_compatibility<ValueType>(); }
/**
 * constructs the random number generator and prepares it for use given an explicit seed
 *
 * @param  seed      A seeding value. An entire state sequence is generated from this value
 *                   using a linear random generator.
 * @tparam ValueType Type of value that should be generated.  Supports integral types,
 *                   Real-number types, and `std::string`.
 */
template <typename ValueType>
RandAnything<ValueType>::RandAnything(unsigned int seed) : _RandBase{seed}  { verify_type_compatibility<ValueType>(); }
/**
 * Generate random value in range [low,high].
 *
 * @param low  smallest value that can be generated
 * @param high largest value that can be generated
 *
 * @tparam ValueType Type of value that should be generated.  Supports integral types,
 *                   Real-number types, and `std::string`.
 * @return a (uniform) random number in the range [low, high]
 */
template <typename ValueType>
ValueType RandAnything<ValueType>::operator() (const ValueType& low, const ValueType& high){
    return generate_rand(low, high, generator, get_type_tag<ValueType>{});
}

/*
 * Worker function to generate random integral value in range [low,high] given an alphabet.
 *
 * @tparam ValueType type of value to produce (only integral types matched by this worker)
 *
 * @param low       lowest possible value to generate
 * @param high      highest possible value to generate
 * @param gen       Mersenne-Twister pseudo-random number generator instance to drive the value generation
 * @return          random value of type `ValueType` in range [low,high]
 */
template <typename ValueType>
ValueType generate_rand(const ValueType& low, const ValueType& high, std::mt19937& gen, integral_type){
    std::uniform_int_distribution<ValueType> distribution{low, high};
    return distribution(gen);
}
/*
 * Worker function to generate random real number in range [low,high) given an alphabet.
 *
 * @tparam ValueType type of value to produce (only floating-point types matched by this worker)
 *
 * @param low       lower bound on values to generate (inclusive)
 * @param high      upper bound on values to generate (non-inclusive)
 * @param gen       Mersenne-Twister pseudo-random number generator instance to drive the value generation
 * @return          random value of type `ValueType` in range [low,high)
 */
template <typename ValueType>
ValueType generate_rand(const ValueType& low, const ValueType& high, std::mt19937& gen, real_type){
    std::uniform_real_distribution<ValueType> distribution{low, high};
    return distribution(gen);
}

std::string generate_rand(std::size_t low,    std::size_t high, const std::string& alphabet, RandAnything<std::size_t>& rnd);
std::string generate_rand(std::size_t length,                   const std::string& alphabet, RandAnything<std::size_t>& rnd);

/**
 * @brief   RandAnything specialization for std::string generation
 * @details Generates std::strings with either a fixed length or with a range of lengths
 *          given an alphabet of characters to choose from (or using all printable characters).
 *          This class also exposes methods to generate several useful alphabets.
 *
 * @tparam   [description]
 */
template < >
class RandAnything<std::string> {
public:
    RandAnything();
    RandAnything(unsigned int seed);
    std::string operator() (std::size_t length, std::string alphabet="");
    std::string operator() (std::size_t min_length, std::size_t max_length, std::string alphabet="");
    std::string alphabet_printable()const;
    std::string alphabet_alphaAllCase()const;
    std::string alphabet_alphaLowerCase()const;
    std::string alphabet_alphaUpperCase()const;
    std::string alphabet_alphaNumeric()const;
    std::string alphabet_numeric()const;
    std::string alphabet_punctuation()const;
    std::string alphabet_hexadecimal()const;
private:
    RandAnything<std::size_t> rnd;
    RandAnything(const RandAnything&)   = delete;
    void operator=(const RandAnything&) = delete;
};
/**
 * Constructs an instance of RandAnything for generating std::string values, using
 * a non-deterministic seed (if available)
 */
inline RandAnything<std::string>::RandAnything() = default;
/**
 * Constructs an instance of RandAnything for generating std::string values, using
 * an explicit seed given by the `seed` parameter.
 *
 * @param seed  seed value that determines the sequence of values produced by the generator
 */
inline RandAnything<std::string>::RandAnything(unsigned int seed)  : rnd{seed} { }
/**
 * @brief   generate a random `std::string` of a specific length from a chosen alphabet
 *
 * @details Generates a `std::string` of characters containing characters chosen at
 *          random from `alphabet` (uniform choice, with replacement).  The length of
 *          the generated string is given by `length`.
 *
 * @param length     length of generated string
 * @param alphabet   set of characters that may appear in the generated string
 * @return  a random string of characters from `alphabet` whose length
 *          is given by `length`
 */
inline std::string RandAnything<std::string>::operator() (std::size_t length, std::string alphabet){
    return (*this)(length, length, alphabet);
}
/**
 * @brief   generate a random `std::string` in a range of lengths from a chosen alphabet
 *
 * @details Generates a `std::string` of characters containing characters chosen at
 *          random from `alphabet` (uniform choice, with replacement).  The minimum and maximum
 *          possible lengths for the generated string are given by `min_length` and `max_length`,
 *          respectively.
 *
 * @param min_length shortest possible string to generate
 * @param max_length longest possible string to generate
 * @param alphabet   set of characters that may appear in the generated string
 * @return  a random string of characters from `alphabet` whose length
 *          is in the range [`min_length`, `max_length`]
 */
std::string RandAnything<std::string>::operator() (std::size_t min_length, std::size_t max_length, std::string alphabet){
    if(alphabet.size() == 0)                              // if the alphabet is blank, use all printable chars
        alphabet = alphabet_printable();
    return generate_rand(min_length, max_length, alphabet, rnd);
}
/**
 * @brief   generates the alphabet of all lowercase alphabetical characters
 * @return  a `std::string` consisting of all lowercase alphabetical characters
 */
std::string RandAnything<std::string>::alphabet_alphaLowerCase()const{
    std::string result;
    for(char ch = 'a'; ch <= 'z'; ++ch)
        result += ch;
    return result;
}
/**
 * @brief   generates the alphabet of all uppercase alphabetical characters
 * @return  a `std::string` consisting of all uppercase alphabetical characters
 */
std::string RandAnything<std::string>::alphabet_alphaUpperCase()const{
    std::string result;
    for(char ch = 'A'; ch <= 'Z'; ++ch)
        result += ch;
    return result;
}
/**
 * @brief   generates the alphabet of all numeric characters
 * @return  a `std::string` consisting of all numeric characters
 */
std::string RandAnything<std::string>::alphabet_numeric()const{
    std::string result;
    for(char ch = '0'; ch <= '9'; ++ch)
        result += ch;
    return result;
}
/**
 * @brief   generates the alphabet of all alphabetical characters (upper- and lower-case)
 * @return  a `std::string` consisting of all alphabetical characters
 */
std::string RandAnything<std::string>::alphabet_alphaAllCase()const{
    return alphabet_alphaLowerCase() + alphabet_alphaUpperCase();
}
/**
 * @brief   generates the alphabet of all alphabetical (upper- and lower-case) and numeric digits
 * @return  a `std::string` consisting of all alphabetical characters and digits
 */
std::string RandAnything<std::string>::alphabet_alphaNumeric()const{
    return alphabet_alphaLowerCase() + alphabet_alphaUpperCase() + alphabet_numeric();
}
/**
 * @brief   generates the alphabet of all punctuation and symbol characters
 *          (all non-whitespace printable characters that are not alphabetical or numeric)
 * @return  a `std::string` consisting of all punctuation and symbol printable characters
 */
std::string RandAnything<std::string>::alphabet_punctuation()const{
    std::string result;
    for(char ch = '!'; ch <= '/'; ++ch)
        result += ch;
    for(char ch = ':'; ch <= '@'; ++ch)
        result += ch;
    for(char ch = '['; ch <= '`'; ++ch)
        result += ch;
    for(char ch = '{'; ch <= '~'; ++ch)
        result += ch;
    return result;
}
/**
 * @brief   generates the alphabet of all printable (non-whitespace) characters
 * @return  a `std::string` consisting of all printable (non-whitespace) characters
 */
std::string RandAnything<std::string>::alphabet_printable()const{
    return alphabet_alphaLowerCase() + alphabet_alphaUpperCase() + alphabet_numeric() + alphabet_punctuation();
}
/**
 * @brief   generates the alphabet of all hexadecimal digits [0,f]
 * @return  a `std::string` consisting of all hexadecimal digits [0,f]
 */
std::string RandAnything<std::string>::alphabet_hexadecimal()const{
    std::string result = alphabet_numeric();
    for(char ch='a'; ch <= 'f'; ++ch)
        result += ch;
    return result;
}
/*
 * Worker function to generate random string with variable length in range [low,high] given an alphabet.
 *
 * @param low       shortest possible string to generate
 * @param high      longest possible string to generate
 * @param alphabet  set of characters to choose random string from (with replacement)
 * @param rnd       RandAnything instance to generate random integer values for driving the random string construction
 * @return          random string with length [low,high] from alphabet
 */
std::string generate_rand(std::size_t low,    std::size_t high, const std::string& alphabet, RandAnything<std::size_t>& rnd){
    auto length = rnd(low, high);
    std::string result;
    for(std::size_t i = 0; i < length; ++i){              // generate `length` random
        result += alphabet[ rnd(0, alphabet.size()-1) ];  // from within the desired alphabet
    }
    return result;                                        // return the resulting random string
}
/*
 * Worker function to generate random string with exact length given an alphabet.
 *
 * @param length    length of string to generate
 * @param alphabet  set of characters to choose random string from (with replacement)
 * @param rnd       RandAnything instance to generate random integer values for driving the random string construction
 * @return          random string with length [low,high] from alphabet
 */
std::string generate_rand(std::size_t length,                   const std::string& alphabet, RandAnything<std::size_t>& rnd){
    return generate_rand(length, length, alphabet, rnd);
}

#endif
